"""
Filename: vulnerability_scanner.py
Author: Mobeen Ali
Date: July 2025

Purpose:
--------
Implements dependency vulnerability scanning for the Secure CLI E-Commerce Application.
Addresses OWASP A06: Vulnerable and Outdated Components by providing automated
vulnerability detection, dependency analysis, and security advisory monitoring.

Security Features:
------------------
- Automated dependency vulnerability scanning
- Security advisory monitoring
- Component inventory management
- Risk assessment and scoring
- Remediation recommendations
- Continuous monitoring and alerts

Usage:
-------
- VulnerabilityScanner.scan_dependencies() -> dict
- VulnerabilityScanner.check_security_advisories() -> list
- VulnerabilityScanner.generate_report() -> str
- VulnerabilityScanner.update_component(component, version) -> bool
"""

import json
import os
import subprocess
import requests
from datetime import datetime, timedelta
from typing import Dict, List, Optional
from app.core.logger import Logger
from enum import Enum

class VulnerabilityLevel(Enum):
    """Vulnerability severity levels."""
    CRITICAL = "Critical"
    HIGH = "High"
    MEDIUM = "Medium"
    LOW = "Low"
    INFO = "Informational"

class ComponentStatus(Enum):
    """Component security status."""
    SECURE = "Secure"
    VULNERABLE = "Vulnerable"
    OUTDATED = "Outdated"
    UNKNOWN = "Unknown"

class VulnerabilityScanner:
    """
    Comprehensive vulnerability scanning system for dependencies and components.
    """
    
    def __init__(self):
        """Initialize vulnerability scanner with configuration."""
        self.components_file = "data/component_inventory.json"
        self.vulnerabilities_file = "data/vulnerability_report.json"
        self.components = self._load_components()
        self.vulnerabilities = self._load_vulnerabilities()
        self.security_advisories = []
        
        # Security advisory sources
        self.advisory_sources = {
            "nvd": "https://services.nvd.nist.gov/rest/json/cves/2.0",
            "github": "https://api.github.com/repos/{owner}/{repo}/security-advisories",
            "pyup": "https://pyup.io/api/v1/security/"
        }
    
    def _load_components(self) -> Dict:
        """Load component inventory from storage."""
        if not os.path.exists(self.components_file):
            return self._initialize_component_inventory()
        
        try:
            with open(self.components_file, 'r') as f:
                return json.load(f)
        except Exception as e:
            Logger.error(f"Failed to load component inventory: {str(e)}")
            return self._initialize_component_inventory()
    
    def _save_components(self):
        """Save component inventory to storage."""
        try:
            with open(self.components_file, 'w') as f:
                json.dump(self.components, f, indent=2)
        except Exception as e:
            Logger.error(f"Failed to save component inventory: {str(e)}")
    
    def _load_vulnerabilities(self) -> Dict:
        """Load vulnerability reports from storage."""
        if not os.path.exists(self.vulnerabilities_file):
            return {}
        
        try:
            with open(self.vulnerabilities_file, 'r') as f:
                return json.load(f)
        except Exception as e:
            Logger.error(f"Failed to load vulnerability report: {str(e)}")
            return {}
    
    def _save_vulnerabilities(self):
        """Save vulnerability reports to storage."""
        try:
            with open(self.vulnerabilities_file, 'w') as f:
                json.dump(self.vulnerabilities, f, indent=2)
        except Exception as e:
            Logger.error(f"Failed to save vulnerability report: {str(e)}")
    
    def _initialize_component_inventory(self) -> Dict:
        """Initialize component inventory with current project dependencies."""
        components = {
            "bcrypt": {
                "name": "bcrypt",
                "version": "4.3.0",
                "type": "python",
                "description": "Password hashing library",
                "status": ComponentStatus.SECURE.value,
                "last_checked": datetime.utcnow().isoformat(),
                "vulnerabilities": [],
                "recommended_version": "4.3.0"
            },
            "pytest": {
                "name": "pytest",
                "version": "latest",
                "type": "python",
                "description": "Testing framework",
                "status": ComponentStatus.SECURE.value,
                "last_checked": datetime.utcnow().isoformat(),
                "vulnerabilities": [],
                "recommended_version": "latest"
            },
            "flake8": {
                "name": "flake8",
                "version": "latest",
                "type": "python",
                "description": "Code linting tool",
                "status": ComponentStatus.SECURE.value,
                "last_checked": datetime.utcnow().isoformat(),
                "vulnerabilities": [],
                "recommended_version": "latest"
            },
            "bandit": {
                "name": "bandit",
                "version": "latest",
                "type": "python",
                "description": "Security linter",
                "status": ComponentStatus.SECURE.value,
                "last_checked": datetime.utcnow().isoformat(),
                "vulnerabilities": [],
                "recommended_version": "latest"
            },
            "pyotp": {
                "name": "pyotp",
                "version": "2.9.0",
                "type": "python",
                "description": "OTP generation library",
                "status": ComponentStatus.SECURE.value,
                "last_checked": datetime.utcnow().isoformat(),
                "vulnerabilities": [],
                "recommended_version": "2.9.0"
            },
            "PyJWT": {
                "name": "PyJWT",
                "version": "2.8.0",
                "type": "python",
                "description": "JWT token library",
                "status": ComponentStatus.SECURE.value,
                "last_checked": datetime.utcnow().isoformat(),
                "vulnerabilities": [],
                "recommended_version": "2.8.0"
            },
            "cryptography": {
                "name": "cryptography",
                "version": "41.0.0",
                "type": "python",
                "description": "Cryptographic library",
                "status": ComponentStatus.SECURE.value,
                "last_checked": datetime.utcnow().isoformat(),
                "vulnerabilities": [],
                "recommended_version": "41.0.0"
            }
        }
        
        self.components = components
        self._save_components()
        return components
    
    def scan_dependencies(self) -> Dict:
        """
        Perform comprehensive vulnerability scan of all dependencies.
        
        Returns:
            Dict: Vulnerability scan results
        """
        scan_results = {
            "scan_timestamp": datetime.utcnow().isoformat(),
            "total_components": len(self.components),
            "vulnerable_components": 0,
            "outdated_components": 0,
            "secure_components": 0,
            "components": {},
            "recommendations": []
        }
        
        for component_name, component_data in self.components.items():
            component_scan = self._scan_component(component_name, component_data)
            scan_results["components"][component_name] = component_scan
            
            if component_scan["status"] == ComponentStatus.VULNERABLE.value:
                scan_results["vulnerable_components"] += 1
            elif component_scan["status"] == ComponentStatus.OUTDATED.value:
                scan_results["outdated_components"] += 1
            else:
                scan_results["secure_components"] += 1
        
        # Generate recommendations
        scan_results["recommendations"] = self._generate_scan_recommendations(scan_results)
        
        # Update vulnerability report
        self.vulnerabilities[scan_results["scan_timestamp"]] = scan_results
        self._save_vulnerabilities()
        
        Logger.info(f"Vulnerability scan completed: {scan_results['vulnerable_components']} vulnerable components found")
        return scan_results
    
    def _scan_component(self, component_name: str, component_data: Dict) -> Dict:
        """
        Scan individual component for vulnerabilities.
        
        Args:
            component_name (str): Component name
            component_data (Dict): Component information
            
        Returns:
            Dict: Component scan results
        """
        scan_result = {
            "name": component_name,
            "current_version": component_data["version"],
            "status": ComponentStatus.SECURE.value,
            "vulnerabilities": [],
            "recommended_version": component_data.get("recommended_version", component_data["version"]),
            "last_updated": datetime.utcnow().isoformat(),
            "risk_score": 0.0
        }
        
        # Check for known vulnerabilities
        vulnerabilities = self._check_component_vulnerabilities(component_name, component_data["version"])
        if vulnerabilities:
            scan_result["vulnerabilities"] = vulnerabilities
            scan_result["status"] = ComponentStatus.VULNERABLE.value
            scan_result["risk_score"] = self._calculate_risk_score(vulnerabilities)
        
        # Check if component is outdated
        if self._is_component_outdated(component_name, component_data["version"]):
            scan_result["status"] = ComponentStatus.OUTDATED.value
            scan_result["risk_score"] = max(scan_result["risk_score"], 0.3)
        
        # Update component status
        self.components[component_name]["status"] = scan_result["status"]
        self.components[component_name]["last_checked"] = scan_result["last_updated"]
        self.components[component_name]["vulnerabilities"] = scan_result["vulnerabilities"]
        
        return scan_result
    
    def _check_component_vulnerabilities(self, component_name: str, version: str) -> List[Dict]:
        """
        Check for known vulnerabilities in a component.
        
        Args:
            component_name (str): Component name
            version (str): Component version
            
        Returns:
            List[Dict]: List of vulnerabilities
        """
        vulnerabilities = []
        
        # Simulate vulnerability checking (in real implementation, this would query security databases)
        # This is a simplified version for demonstration purposes
        
        # Example vulnerability checks for common components
        if component_name == "cryptography" and version < "42.0.0":
            vulnerabilities.append({
                "id": "CVE-2024-1234",
                "title": "Cryptographic vulnerability in older versions",
                "severity": VulnerabilityLevel.HIGH.value,
                "description": "Older versions of cryptography library have known vulnerabilities",
                "affected_versions": "<42.0.0",
                "fixed_version": "42.0.0",
                "published_date": "2024-01-15",
                "references": ["https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-1234"]
            })
        
        elif component_name == "PyJWT" and version < "2.9.0":
            vulnerabilities.append({
                "id": "CVE-2024-5678",
                "title": "JWT token validation vulnerability",
                "severity": VulnerabilityLevel.CRITICAL.value,
                "description": "Older versions of PyJWT have critical security vulnerabilities",
                "affected_versions": "<2.9.0",
                "fixed_version": "2.9.0",
                "published_date": "2024-03-20",
                "references": ["https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-5678"]
            })
        
        return vulnerabilities
    
    def _is_component_outdated(self, component_name: str, version: str) -> bool:
        """
        Check if a component is outdated.
        
        Args:
            component_name (str): Component name
            version (str): Current version
            
        Returns:
            bool: True if component is outdated
        """
        # Simplified version checking (in real implementation, this would query package repositories)
        # Define minimum required versions for each component
        minimum_versions = {
            "cryptography": "41.0.0",  # Minimum secure version
            "PyJWT": "2.8.0",          # Minimum secure version
            "bcrypt": "4.3.0"          # Minimum secure version
        }
        
        if component_name in minimum_versions:
            return version < minimum_versions[component_name]
        
        return False
    
    def _calculate_risk_score(self, vulnerabilities: List[Dict]) -> float:
        """
        Calculate risk score based on vulnerabilities.
        
        Args:
            vulnerabilities (List[Dict]): List of vulnerabilities
            
        Returns:
            float: Risk score (0.0 to 1.0)
        """
        if not vulnerabilities:
            return 0.0
        
        severity_scores = {
            VulnerabilityLevel.CRITICAL.value: 1.0,
            VulnerabilityLevel.HIGH.value: 0.8,
            VulnerabilityLevel.MEDIUM.value: 0.5,
            VulnerabilityLevel.LOW.value: 0.2,
            VulnerabilityLevel.INFO.value: 0.1
        }
        
        max_score = 0.0
        for vuln in vulnerabilities:
            severity = vuln.get("severity", VulnerabilityLevel.MEDIUM.value)
            score = severity_scores.get(severity, 0.5)
            max_score = max(max_score, score)
        
        return max_score
    
    def check_security_advisories(self) -> List[Dict]:
        """
        Check for security advisories from various sources.
        
        Returns:
            List[Dict]: List of security advisories
        """
        advisories = []
        
        # Simulate checking security advisories (in real implementation, this would query APIs)
        # This is a simplified version for demonstration purposes
        
        # Example advisories for demonstration
        advisories = [
            {
                "id": "ADV-2023-001",
                "title": "Critical vulnerability in cryptography library",
                "severity": VulnerabilityLevel.CRITICAL.value,
                "affected_components": ["cryptography"],
                "description": "A critical vulnerability has been discovered in the cryptography library",
                "published_date": "2023-06-15",
                "source": "NVD",
                "url": "https://nvd.nist.gov/vuln/detail/CVE-2023-1234"
            },
            {
                "id": "ADV-2023-002",
                "title": "High severity vulnerability in PyJWT",
                "severity": VulnerabilityLevel.HIGH.value,
                "affected_components": ["PyJWT"],
                "description": "A high severity vulnerability has been discovered in PyJWT",
                "published_date": "2023-07-20",
                "source": "GitHub Security Advisories",
                "url": "https://github.com/jpadilla/pyjwt/security/advisories/GHSA-1234"
            }
        ]
        
        self.security_advisories = advisories
        Logger.info(f"Retrieved {len(advisories)} security advisories")
        return advisories
    
    def update_component(self, component_name: str, new_version: str) -> bool:
        """
        Update a component to a new version.
        
        Args:
            component_name (str): Component name
            new_version (str): New version
            
        Returns:
            bool: True if update was successful
        """
        if component_name not in self.components:
            return False
        
        try:
            # Update component version
            self.components[component_name]["version"] = new_version
            self.components[component_name]["last_updated"] = datetime.utcnow().isoformat()
            self.components[component_name]["status"] = ComponentStatus.SECURE.value
            
            # Re-scan component
            scan_result = self._scan_component(component_name, self.components[component_name])
            
            self._save_components()
            
            Logger.info(f"Updated component {component_name} to version {new_version}")
            return True
            
        except Exception as e:
            Logger.error(f"Failed to update component {component_name}: {str(e)}")
            return False
    
    def generate_report(self, format: str = "json") -> str:
        """
        Generate comprehensive vulnerability report.
        
        Args:
            format (str): Report format (json, html, csv)
            
        Returns:
            str: Generated report
        """
        # Perform fresh scan
        scan_results = self.scan_dependencies()
        
        # Check security advisories
        advisories = self.check_security_advisories()
        
        report = {
            "report_timestamp": datetime.utcnow().isoformat(),
            "scan_results": scan_results,
            "security_advisories": advisories,
            "summary": {
                "total_components": scan_results["total_components"],
                "vulnerable_components": scan_results["vulnerable_components"],
                "outdated_components": scan_results["outdated_components"],
                "secure_components": scan_results["secure_components"],
                "total_advisories": len(advisories),
                "critical_advisories": len([a for a in advisories if a["severity"] == VulnerabilityLevel.CRITICAL.value]),
                "high_advisories": len([a for a in advisories if a["severity"] == VulnerabilityLevel.HIGH.value])
            },
            "recommendations": scan_results["recommendations"]
        }
        
        if format == "json":
            return json.dumps(report, indent=2)
        elif format == "html":
            return self._generate_html_report(report)
        elif format == "csv":
            return self._generate_csv_report(report)
        else:
            raise ValueError(f"Unsupported format: {format}")
    
    def _generate_scan_recommendations(self, scan_results: Dict) -> List[str]:
        """
        Generate recommendations based on scan results.
        
        Args:
            scan_results (Dict): Scan results
            
        Returns:
            List[str]: List of recommendations
        """
        recommendations = []
        
        if scan_results["vulnerable_components"] > 0:
            recommendations.append(
                f"Immediately update {scan_results['vulnerable_components']} vulnerable components"
            )
        
        if scan_results["outdated_components"] > 0:
            recommendations.append(
                f"Update {scan_results['outdated_components']} outdated components to latest versions"
            )
        
        if scan_results["secure_components"] < scan_results["total_components"]:
            recommendations.append(
                "Implement automated dependency scanning in CI/CD pipeline"
            )
        
        recommendations.append(
            "Set up automated security advisory monitoring"
        )
        
        return recommendations
    
    def _generate_html_report(self, report: Dict) -> str:
        """Generate HTML format report."""
        # Simplified HTML report generation
        html = f"""
        <html>
        <head><title>Vulnerability Report</title></head>
        <body>
        <h1>Vulnerability Report</h1>
        <p>Generated: {report['report_timestamp']}</p>
        <h2>Summary</h2>
        <ul>
        <li>Total Components: {report['summary']['total_components']}</li>
        <li>Vulnerable Components: {report['summary']['vulnerable_components']}</li>
        <li>Outdated Components: {report['summary']['outdated_components']}</li>
        <li>Secure Components: {report['summary']['secure_components']}</li>
        </ul>
        </body>
        </html>
        """
        return html
    
    def _generate_csv_report(self, report: Dict) -> str:
        """Generate CSV format report."""
        # Simplified CSV report generation
        csv_lines = [
            "Component,Version,Status,Vulnerabilities,Risk Score",
        ]
        
        for component_name, component_data in report['scan_results']['components'].items():
            csv_lines.append(
                f"{component_name},{component_data['current_version']},"
                f"{component_data['status']},{len(component_data['vulnerabilities'])},"
                f"{component_data['risk_score']}"
            )
        
        return "\n".join(csv_lines)

# Global vulnerability scanner instance
vulnerability_scanner = VulnerabilityScanner() 